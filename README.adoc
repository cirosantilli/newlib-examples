= Crosstool-NG Newlib Examples
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc: macro
:toclevels: 6
:toc-title:

Run one command, get bare metal arm UART minimal examples that run on QEMU or gem5, written in C using the C standard library via Newlib, with a clean toolchain built with Crosstool-NG. Tested on Ubuntu 18.04.

toc::[]

== Getting started

Clone, build and run on QEMU:

....
git clone https://github.com/cirosantilli/newlib-examples
cd newlib-examples
git submodule update --recursive
./build-ctng && ./build-qemu && ./build-samples && ./run
....

Outcome: QEMU starts, go to the terminal and type the keys:

* `'a'`
* `'b'`

and watch QEMU reply as you type with:

....
97: a
new alloc of 1 bytes at address 0x1A2E0
Heap end = 0x1B000
98: b
new alloc of 2 bytes at address 0x1A2E0
Heap end = 0x1B000
....

To exit enter:

....
Ctrl-A X
....

This example illustrates the following Newlib syscall implementations:

* `read` to get user UART input
* `write` to give UART output
* `sbrk` for `malloc`

=== ARMv8

TODO get working.

Use ARMv8 instead of ARMv7:

....
./build-ctng -aA && ./build-qemu -aA && ./build-samples -aA && ./run -aA
....

How it fails currently: prints:

....
enter a character
....

then you enter a character, then it goes into an interrupt loop.

The interrupt loop happens inside the:

....
printf("got: %c\n", c);
....

because GCC compiled it into:

....
str    q0, [sp, #80]
....

which uses NEON registers, which must be raising an exception? TODO details. Related: https://stackoverflow.com/questions/19231197/enable-neon-on-arm-cortex-a-series

This can be found by logging instructions with:

....
while(1)
stepi
end
....

or by hacking the QEMU CLI to contain:

.....
-D log.log -d in_asm
.....

The first `printf`:

....
printf("enter a character\n");
....

does not blow up because GCC compiles it into `puts` directly since it has no arguments.

=== GDB

Shell 1:

....
./run -d
....

Shell 2:

....
./rungdb
....

Now QEMU is at the first instruction of link:startup_arm.S[], and you can step debug as usual.

The address is `0x40000000`, which is what we set the `ENTRY` to in link:link.ld[]. If you change that, it will still work: QEMU just parses the ELF entry field, places the code there in memory, and sets PC to it.

=== gem5

Run on `gem5` instead of QEMU:

....
./build-gem5
./run -g
....

On another shell:

....
./gem5-shell
....

TODO: this is printing newlines without automatic carriage return `\r` as in:

....
enter a character
                 got: a
....

We use `m5term` by default, and if we try `telnet` instead:

....
telnet localhost 3456
....

it does add the carriage returns automatically.

=== Ubuntu distro toolchain

If you are really lazy, and don't want to wait 10 minutes for the toolchain or QEMU to build, you can also do just:

....
sudo apt-get install gcc-arm-none-eabi qemu-system-arm
./build-samples -p arm-none-eabi-
./run -h
....

Shame on you.

== Why this is cool

Usually, when you have to explain something, it is already not cool, but here goes in any case.

This allows you to run C programs without an operating system, directly on bare metal, and use a subset of the C standard library.

This allows you to run possibly unmodified C programs directly on bare metal.

Furthermore, we build a completely pristine GCC from source via crosstool-ng, therefore dispensing any distro provided blobs.

== Directory structure

=== ctng_defconfig

Contains crosstool-ng defconfigs. To generate those, do:

....
# Generates the base config.
./build-ctng
cd crosstool-ng
./ct-ng menuconfig
./ct-ng savedefconfig
cp defconfig ../../ctng_defconfig/<yourname>
....

== How to find the UART address

Enter the QEMU console:

....
Ctrl-X C
....

Then do:

....
info mtree
....

And look for `pl011`:

....
    0000000009000000-0000000009000fff (prio 0, i/o): pl011
....
